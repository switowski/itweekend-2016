<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <title>Writing fast Python</title>
        <meta name="description" content="Presentation about source code level optimizations for Python">
        <meta name="author" content="Sebastian Witowski">

        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

        <link rel="stylesheet" href="css/reveal.css">

        <!-- Reveal.js theme -->
        <link rel="stylesheet" href="css/theme/blood.css">
        <!-- Custom CSS rules -->
        <link rel="stylesheet" href="css/custom.css">
        <!-- Theme used for syntax highlighting of code -->
        <link rel="stylesheet" href="lib/css/gruvbox-dark.css">
        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>
    </head>
    <body>
        <div class="reveal">
            <div class="slides">
<!--                 <section>
                    <small>This page is intentionally left blank</small>
                </section>
 -->                <section>
                    <!-- Vertical slides for different title variations -->
                    <section>
                        <h1>Writing faster code</h1>
                        <aside class="notes">
                            Hi everyone.<br>
                            I would like to talk with you about writing faster code. I remember the first time I was talking about making code faster - it was during some lightning talks, and I asked the audience what is in their opinion the best way to make Python code faster.<br>
                            And there was this one guy there - you know this type of an old school programmer that doesn't believe in Agile or TDD - who said "Well, rewrite your code in C".<br>
                            And you know what? The guy was absolutely right. Take any piece of Python code, rewrite it in C or C++ and it will probably be faster.<br>
                            I decided that the only way to prevent this kind of mistakes is to have a very clear title of the presentation.<br>
                        </aside>
                    </section>
                    <section>
                        <h2>Writing faster code <span class='orange'>and not hating your job as a software developer</span></h2>
                        <aside class="notes">
                            So I changed the title of my presentation to avoid any misunderstandings.<br>
                            And I was very happy with the new title. It makes it clear that we are not gonna talk about C or C++ today.<br>
                            But then I realized that this title is too long, I mean even though it's very clear, it barely even fits on the slide.<br>
                            So I had to change it again.<br>
                        </aside>
                    </section>
                    <section>
                        <h1 class="mb150">Writing faster <span class='orange'>Python</span></h1>
                        <p class="source-link"><a href="https://github.com/switowski">@SebaWitowski</a></p>
                        <aside class="notes">
                            And I got the version that means exactly the same thing but is shorter.<br>
                            So this is how I came up with the title for my today's talk.<br>
                            Let's put aside the flame war about which programming language is better.<br>
                            (Whisper) We all know the answer, that's why you guys are on this track :)(/Whisper)
                        </aside>
                    </section>
                </section>
                <section>
                    <section>
                        <h4 class="source-link" style='font-size:1.2em; margin-top:150px'>Sebastian Witowski</h4>
                        <div>
                            <img class="no-borders" style="height:200px;width:200px;" src="./img/cern_logo.png">
                        </div>
                        <aside class="notes">
                            First of all, who am I and why do I care about faster Python ?<br>
                            My name is Sebastian Witowski and I work at CERN.<br>
                            And I'm lucky enough to be working at CERN during a very interesting period of time.<br>
                            You see, for many years, scientists have been using a programming language called R.<br>
                            It's a language mostly designed for statistical computing.<br>
                        </aside>
                    </section>
                    <section style='width:1100px; left:-60px;'>
                        <pre style='width:100%;height:650px;'><code class='R' style='min-height:100%;' data-trim data-noescape>
# https://en.wikipedia.org/wiki/R_(programming_language)
install.packages("caTools")
library(caTools)
jet.colors <- colorRampPalette(c("green", "blue", "red",
                                 "cyan", "#7FFF7F",
                                 "yellow", "#FF7F00",
                                 "red", "#7F0000"))
m <- 1000
C <- complex( real=rep(seq(-2.10,0.8, length.out=m), each=m ),
              imag=rep(seq(-1.2,1.2, length.out=m), m ) )
C <- matrix(C,m,m)
Z <- 0
X <- array(0, c(m,m,20))
for (k in 1:20) {
  Z <- Z^2+C
  X[,,k] <- exp(-abs(Z))
}
write.gif(X, "Mandelbrot.gif", col=jet.colors, delay=900)
                            </code></pre>
                        <aside class="notes">
                            As you can see, R is probably not the most beautiful language<br>
                            But it's fine. If you want to visualize some data, you write a script, display a plot, paste it in your paper and you are done.<br>
                            Well, it was fine until some people discovered that since they know the basics of R, they can use it to write scripts to manipulate some data or do other tasks.<br>
                        </aside>
                    </section>
                    <section>
                        <h3>Small scripts...</h3>
                        <pre><code class='R' data-trim data-noescape>
# Fibonacci sequence (from rosettacode)

recfibo <- function(n) {
  if ( n < 2 ) n
  else Recall(n-1) + Recall(n-2)
}

# Print the first 21 elements
print.table(lapply(0:20, recfibo))
                        </code></pre>
                        <aside class="notes">
                            So scientists - people very often with absolutely no background in programming - started writing simple scripts in R.<br>
                            And as it happens with all the "temporary scripts" - they were passed down from one generation of scientists to another.<br>
                            So every now and then, someone added a couple lines of code to that script.<br>
                        </aside>
                    </section>
                    <section data-background-image="./img/big-script.png">
                        <h1>...will grow</h1>
                        <aside class="notes">
                            And suddenly small scripts became big scripts.<br>
                            It's like those Perl scripts for some administrative tasks that are stored in the miscellaneous folder and no one has any idea who wrote them in the first place.<br>
                            If you don't those scripts in a clean, idiomatic way from the beginning, then at some point they are doomed.<br>
                            As long as they work it's fine, but when if something breaks, you usually need to rewrite it.<br>
                            So scientists started to look for alternatives - an easy to use language that provides simple tools for data analysis, but can also be used for any other tasks.<br>
                            And for many years there was no easy replacement.
                        </aside>
                    </section>
                    <section>
                    <img class="no-borders" src="./img/ipython.png">
                        <aside class="notes">
                            Everyone had his own preferences for the programming language, so some people slowly started moving to Python long time ago, but they still used R for the visualizations.<br>
                            But at some point Python got the IPython tool, together with the amazing IPython notebooks.<br>
                            It allowed for super easy visualizations, directly in the browser and it became extremely popular among scientists.<br>
                            So since last 2 or 3 years I have observed that many scientists moved from R or other "interesting" programming languages to Python and the IPython notebook (now called Jupiter notebook) became a de facto standard for data visualizations.<br>


                            Even though most people are happy with Python, some of them complain that Python is slow.<br>
                            One of the reasons why Python is slow is because programmers, especially those who come to Python from a different programming language, write non idiomatic code.<br>
                            I don't mean that idiomatic code will give you some orders of magnitude speed improvements.<br>
                            No, still, non-idiomatic C code will probably be faster than idiomatic Python code.<br>
                            But that's not the reason why people decide to use Python.
                            <!-- But that's now the point. Companies use Python for a reason.<br> -->
                            <!-- For example, in my team we do a lot of web development and due to the nature of CERN, we have many people coming for short periods of time (few months to 1-2 years).<br> -->
                            <!-- Sure, we could go for some sophisticated web framework, but if we want to enable people to quickly start writing an easy to maintain code, Python was the best choice-->
                        </aside>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Python was not made to be fast...</h4>
                        <h4>...but to make developers fast.</h4>
                        <aside class="notes">
                            Python was not created to be a fast language and it's definitely not used for the LHC where every nanosecond of delay means that scientists will lose data.<br>
                            And that's fine with me. There are many other areas where Python can be used.<br>
                        </aside>
                    </section>
                    <section data-background="#f7f3de">
                        <div class="blockquote">
                            <blockquote>
                                <p>It was nice to learn Python;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
                                a nice afternoon</p>
                            </blockquote>
                            <div class="blockquote-attribution">
                                <p class="blockquote-author">
                                    Donald Knuth
                                </p>
                                <div class="blockquote-picture knuth"></div>
                            </div>
                        </div>
                        <aside class="notes">
                            For example, in our team we do a lot of web development and due to the nature of CERN, most of the people are coming for short periods of time (from a few months to 1 or 2 years).<br>
                            That's one of the reasons why we decided to go for Python - even people with little to no knowledge of Python were able to quickly start using it and contribute to the projects.<br>
                            More importantly, the code that was created was easy to maintain in the future.<br>
                        </aside>
                    </section>
                    <section>
                        <p>Would you like your FIRST program EVER to be like:<br><br></p>
                        <pre><code class='python' data-trim data-noescape>
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, world!");
    }
}
                        </code></pre>
                        <p>or</p>
                        <pre><code class='python' data-trim data-noescape>
print("Hello, world!")
                        </code></pre>
                        <aside class="notes">
                            It's very easy to read and write code in Python, which makes it a perfect language to learn program.
                            I mean, imagine you are completely new to programming and someone tells you: "Hey, let me show you how much fun is the programming. Let's start with something super simple and write some text to the screen."<br>
                            And then he shows you one of those examples.<br>
                            I mean, one of them is clearly not something that you would show to a beginner to encourage him or her to start programming.
                        </aside>
                    </section>
                    <section data-background="#f7f3de">
                        <img class="no-borders" src="./img/logos.png">
                        <p></p>
                        <small class='source-link'>Source: <a href="https://www.shoop.io/en/blog/25-of-the-most-popular-python-and-django-websites">https://www.shoop.io/en/blog/25-of-the-most-popular-python-and-django-websites</a></small>
                        <aside class="notes">
                            But Python is not only useful for learning.<br>
                            There are many big companies that are using Python.<br>
                            Companies with millions of users and billions of requests per month, so I think your website will also be fine with Python.
                        </aside>
                    </section>
                </section>
                <section>
                    <section>
                        <h1 class='h1-smaller'>OPTIMIZATION</h1>
                        <aside class="notes">
                            So Python is usually fast enough. But what if we decide it's not fast enough anymore.<br>
                            For example, your website starts giving timeouts to your users or maybe a faster code will bring more money for your company.<br>
                            It's time for optimization!
                        </aside>
                    </section>
                    <section data-background="#f7f3de">
                        <img src="./img/google-optimization.png">
                        <aside class="notes">
                            But how do you optimize your code ?<br>
                            Probably you need to follow some rules, so let's try to google that.<br>
                            And if we open the first link...<br>
                        </aside>
                    </section>
                    <section data-background="#f7f3de">
                        <img src="./img/optimization-rules.png">
                        <aside class="notes">
                            ... we see that there are only 3 rules.<br>
                            Wow, optimization might be easier than we expected!<br>
                            Let's take a closer look at those rules.
                        </aside>
                    </section>
                    <section>
                        <h3>1. Don't</h3>
                        <h3 class="fragment">2. Don't...&nbsp;yet</h3>
                        <ul class="fragment current-visible remove" style="padding-left:325px;">
                            <li>Finish your code</li>
                            <li>Have tests</li>
                            <li>Now</li>
                        </ul>
                        <h3 class="fragment">3. Profile</h3>
                        <ul class="fragment" style="padding-left:160px;">
                            <li>cProfile</li>
                            <li>pstats</li>
                            <li>RunSnakeRun, SnakeViz</li>
                        </ul>
                        <aside class="notes">
                            First rule of optimization: Don't. Ok, that was easy. Thanks for listening, any questions ?<br>
                            Well, actually no, there is more to that.<br>
                            So what does it mean 'Don't' ?<br>
                            Well, 9 out of 10 times when you think you need optimization, you don't, especially in the early stage of your product's life.<br>
                            You might think it would be nice to optimize your code a bit, but first of all, you will waste time doing something that is probably not needed.<br>
                            If you want your code to run faster, you can start with getting faster hardware in the first place.<br>
                            Second of all, optimization comes with a cost. Most often the only cost is the time you spend optimizing the existing code.<br>
                            Sometimes, it's also the time needed to fix what you just broke with your optimization.<br>
                            But also, the optimized code might not be as readable as it was in the first place.<br>
                            And maybe your code is now running faster but it uses more memory ?<br>
                            So unless you have really good reasons to optimize - don't do this.<br>
                            If you know that you really need to optimize, then you can move to the second rule of optimization<br>
                            ###CLICK###<br>
                            Don't do this yet.<br>
                            This is how I understand this rule:<br>
                            ###CLICK###<br>
                            First make sure your code works<br>
                            Then make sure you have a good test suite<br>
                            And only then, you are ready for optimization.<br>
                            I love this rule, it always reminds me how many times I broke it.<br>
                            I mean, so many times I was in the middle of working on something and then I started thinking: "Hmm, I can change that piece of code and probably it will be faster - also I will save 2 lines of code".<br>
                            Was it a good idea ?<br>
                            Nope. And not only because I ended up breaking things. Well, quite often I did end up breaking things, but also, when I started jumping around the code, I forgot what I was writing in the first place.<br>
                            Did it make my code faster ?<br>
                            I have no idea, because I had nothing to compare it to! If I had written the whole function first and then improve it, I could measure it and see if it's now better or worse, but otherwise I can only guess.<br>
                            And that brings me to the last rules of optimization - Don't guess.<br>
                            ###CLICK###<br>
                            Always profile your code before optimization. Human are terrible in predicting bottlenecks of the code.<br>
                            If your code is slow - profile it and see what takes most of the time.<br>
                            Otherwise, you might end up spending time to rewrite part of your code just to make it 1% faster, while there are other parts of the system where you can gain much more improvements with less effort.<br>
                            ###CLICK###<br>
                            There are plenty of profiling tools.<br>
                            There are a few talks about profiling that you can check, so I will not go into details here.<br>
                            If you don't know where to start, you can try the built-in Python profiler called cProfile.<br>
                            It will show you a clear overview of how many times each function is called and where your code is spending most of the time.<br>
                            You can combine it with the pstats module, which allows for more advanced formatting of the results.<br>
                            If you prefer a graphical interface, you can take a look at libraries like RunSnakeRun and SnakeViz.
                        </aside>
                    </section>
                </section>
                <section>
                    <section>
                        <h3>Levels of optimization</h3>
                        <ul>
                            <li class="fragment">Design</li>
                            <li class="fragment">Algorithms and data structures</li>
                        </ul>
                        <aside class="notes">
                            Once we are ready for optimization, we have to decide, on which area we want to focus.<br>
                            There are different levels of optimization:<br>
                            ###CLICK###<br>
                            Starting from the highest level, you have the design level optimization. Depending on the constrains and priorities of your system, you can optimize it by redesigning it. It might require rewriting parts or the whole application in a different programming language, changing the type of a database or redesigning the architecture of your software to limit the number of DB queries.<br>
                            This type of optimization can give you the best improvement, but also takes the most time to do this.<br>
                            I don't encourage you to rewrite your software from the scratch, but if you have some critical parts of the code that are run often, you can optimize them by rewriting it in C or C++. Because C is faster, you can get some good speed improvement for free. Well, not really for free - now you have to maintain Python AND C/C++ code in one project.<br>
                            ###CLICK###<br>
                            One level lower, we have algorithms and data structures. That is usually the second biggest improvement you can get after a complete redesign. Knowing different algorithms together with their complexity definitely helps creating good and fast software.
                        </aside>
                    </section>
                    <section>
                        <pre><code class='python' data-trim data-noescape>
sum = 0
for x in range(1, N + 1):
    sum += x
print sum
                        </code></pre>
                        <div class="fragment">
                            <p class="arrow">&#8595;</p>
                            <pre><code class='python' data-trim data-noescape>
print N * (1 + N) / 2
                            </code></pre>
                        </div>
                        <aside class="notes">
                            For example, if you want to get the sum of numbers from 1 to N, the first idea might be a loop that goes though all elements and adds them.<br>
                            It will work, but it won't be fast.<br>
                            ###CLICK###<br>
                            You can instead use an algorithm for the arithmetic sum, which will give you the same results and it will be more efficient.
                        </aside>
                    </section>
                    <section>
                        <h3>Levels of optimization</h3>
                        <ul>
                            <li>Design</li>
                            <li>Algorithms and data structures</li>
                            <li>Source code</li>
                            <li class="fragment">Build level</li>
                            <li class="fragment">Compile level</li>
                            <li class="fragment">Runtime level</li>
                        </ul>
                        <aside class="notes">
                            Next level is the source code optimization.<br>
                            This is something that I will talk about more in the second part of the presentation.<br>
                            ###CLICK###<br>
                            Now we are moving to the low levels of optimization.<br>
                            For example, "build level" involves setting up specific build flags.<br>
                            In you daily work, it's not something that you do often.<br>
                            You can optimize Python for a specific architecture, but if you are a web-developer like me, you will probably do this only once for each machine or you won't bother at all.<br>
                            ###CLICK###<br>
                            Next, the compile level.<br>
                            You can make some optimizations if your programming language is using an Ahead of Time compiler.<br>
                            Since, I'm talking about the CPython, that doesn't have an Ahead of Time compiler, we skip this part as well.<br>
                            ###CLICK###<br>
                            Last but not least - runtime level.<br>
                            It's related with a specific compiler you are using.<br>
                            Some compilers are faster than the others, for example if you replace CPython with PyPy, in some specific cases you can gain on average up to 7 times speed improvement, but again, it depends on what kind of tasks you are doing.<br>
                            Most of the time, once we set up on a specific language implementation, there is nothing we have to do to benefit from this kind of optimization - it's up to the creators of the compilers to optimize them, so simply updating to the new version of the programming language can make your code run a bit faster.
                        </aside>
                    </section>
                </section>
                <!-- Optimization is not only the speed -->
                <section>
                    <section>
                        <h4>Optimization is all about the speed</h4>
                        <div class="fragment">
                            <h4>... and memory</h4>
                        </div>
                        <div class="fragment">
                            <h4>... and disk space</h4>
                            <h4>... disk I/O</h4>
                            <h4>... network I/O</h4>
                            <h4>... power consumption</h4>
                            <h4>... and more.</h4>
                        </div>
                        <aside class="notes">
                            So, when you optimize you probably want your code to run faster.<br>
                            ###CLICK###<br>
                            And also use less memory.<br>
                            ###CLICK###<br>
                            And basically less of everything.<br>
                            The bad news is - you can't have all of this.<br>
                            Optimization in one area will usually cause deterioration in other areas.<br>
                            You always have to decide, which resources are crucial to you and try to optimize in that direction.<br>
                            So it's possible that optimization will have nothing to do with the execution time at all, as there can be other resources more important than the raw speed.<br>
                            For example, who cares if your program is now 10 times faster if it's crashing half of the time, because it's running out of memory ?
                        </aside>
                    </section>
                    <section data-background="#f7f3de">
                        <div class="blockquote">
                            <blockquote>
                                <p>Always code as if the guy who ends up maintaining your code will be a violent psychopath who knows where you live</p>
                            </blockquote>
                            <div class="blockquote-attribution">
                                <p class="blockquote-author">
                                    John Woods
                                </p>
                            </div>
                        </div>
                        <aside class="notes">
                            Another important resource of optimization that people are often forgetting is the sanity.<br>
                            Sanity of a person, who will be maintaining your code. So please, be nice to that person, you never know who that might be.<br>
                            Unless you are really writing a throw-away code, if you are making the code harder to read and maintain, then you are probably doing it wrong!
                        </aside>
                    </section>
                </section>
                <!-- SOURCE CODE OPTIMIZATION -->
                <section>
                    <section>
                        <h2>Writing fast Python</h2>
                        <h5>a.k.a source code optimization</h5>
                        <aside class="notes">
                            Having those things cleared, let's jump straight to how you can write faster Python, also known as source code optimization.<br>
                        </aside>
                    </section>
                    <section>
                        <h3 class="mb50">Setup</h3>
                        <p class="mb50">Python 3.5.1 (IPython 1.2.1)</p>
                        <pre><code class='python' data-trim data-noescape>
def ultimate_answer_to_life():
    return 42
                        </code></pre>
                        <p>&nbsp;</p>
                        <pre><code class='python' data-trim data-noescape>
>>> %timeit ultimate_answer_to_life()
10000000 loops, best of 3: 87.1 ns per loop
                        </code></pre>
                        <p>&nbsp;</p>
                        <p class="source-link">
                            2.72 × 10<sup>21</sup> times faster than in <a href="https://en.wikipedia.org/wiki/42_(number)#Hitchhiker.27s_Guide_to_the_Galaxy">The Hitchhiker's Guide to the Galaxy</a> ;-)
                        </p>
                        <aside class="notes">
                            In my examples, I'm using version 3.5.1 of Python together with the IPython, although all the examples should apply to both Python 2 and 3.<br>
                            For measuring execution time of code, I will use the magic %timeit function.<br>
                            It has some overhead comparing with the standard timeit library, but it doesn't really matter - as long as we use the same method to measure execution time of different functions, we only need to know which method is faster and by how much.<br>
                            So for each of my examples, I write different versions of code, measure the execution time and compare them.
                        </aside>
                    </section>
                </section>

                <!-- Counting elements in a list -->
                <section>
                    <section>
                    <h4 class="mb50"><span class="orange">#1</span> Count elements in a list</h4>
                        <pre><code class='python' data-trim data-noescape>
how_many = 0
for element in ONE_MILLION_ELEMENTS:
    how_many += 1
print how_many
                        </code></pre>
                        <p>
                            <span class="bad">26.5 ms</span>
                        </p>
                        <pre><code class='python' data-trim data-noescape>
print len(ONE_MILLION_ELEMENTS)
                        </code></pre>
                        <p>
                            <span class="good">96.7 ns</span>
                        </p>
                        <p>
                            <span class="good">274 000</span> times faster
                        </p>
                        <aside class="notes">
                            Let's start with something simple. Let's say you want to count the number of elements in a list.<br>
                            You can easily write a simple loop that increments a counter and, while this will work, it will be very slow.<br>
                            You can achieve the same results by simply calling the built-in function len().<br>
                            And as you can see even for only 1 million elements, the speed difference is insanely huge.<br>
                            So, my first advice is to not reinvent the wheel, but first check if there is a function that you can use.
                        </aside>
                    </section>
                    <section data-background="#f7f3de">
                        <img src="./img/built-ins.png">
                        <small class="source-link">And <a href="https://docs.python.org/3/library/collections.html">collections</a> module.</small>
                        <aside class="notes">
                            Python 3.5.1 has 68 built-in functions, so it's good to take a look at them from time to time and keep them in the back of your head, because they might be handy at some point.<br>
                            Also, before you start writing your own version of ordered dictionary or dictionary with default values, take a look at the collections module from the standard library.<br>
                            Even though it contains only like 10 different datatypes, they are probably THE datatypes you are looking for when the standard ones are not enough.
                        </aside>
                    </section>
                </section>


                <!-- Filter a list -->
                <section>
                <h4 class="mb50"><span class="orange">#2</span> Filter a list</h4>
                    <pre><code class='python' data-trim data-noescape>
output = []
for element in MILLION_NUMBERS:
    if element % 2:
        output.append(element)
                    </code></pre>
                    <p>
                        <span class="bad">222 ms</span>
                    </p>
                    <div class='fragment'>
                        <pre><code class='python' data-trim data-noescape>
list(filter(lambda x: x % 2, MILLION_NUMBERS))
                        </code></pre>
                        <p>
                            <span class="bad">234 ms</span>
                        </p>
                    </div>
                    <div class='fragment'>
                        <pre><code class='python' data-trim data-noescape>
[item for item in MILLION_NUMBERS if item % 2]
                        </code></pre>
                        <p>
                            <span class="good">127 ms</span><br>
                            75% faster
                        </p>
                    </div>
                    <aside class="notes">
                        Let's say you have a list of 1 million numbers and you want to select only the odd numbers.<br>
                        The naive version would be to use a for loop, so for each element of the list you check if it's odd and if it is, the you add it to another list.<br>
                        But I already showed you in the previous example that in most cases, for loops can be replaced with something better.<br>
                        ###CLICK###<br>
                        In this case, you could use the built-in filter function instead.<br>
                        In Python 2, filter was returning a list directly.<br>
                        In Python 3, it's returning an iterator, so I need to call the list function on that iterator to get the same results as in case of the loop.<br>
                        Even though calling list function has some impact on the performance, it's negligible comparing to the time spent in the filter function.<br>
                        But as we can see, filter performs even slower than the for loop.<br>
                        Why does this happen ?<br>
                        Well, the fact that filter is now returning an iterator is a clear suggestion that this is a wrong use case for the filter function.<br>
                        ###CLICK###<br>
                        If we want to get the whole list as a result, the better idea is to use list comprehension.<br>
                        It's around 75% faster than the for loop and - at least for me - it looks very clear.
                    </aside>
                </section>


                <!-- List with index -->
                <!-- REMOVED AS IT'S TOO COMPLICATED AND DOESN'T BRING MUCH PROFIT (APART FROM MENTIONING THE GENERATOR COMPREHENSION) -->
                <!-- <section>
                    <h4 class="mb50"><span class="orange">#2.5</span> List with index</h4>
                    <pre><code class='python' data-trim data-noescape>
output = {}
for i in range(0, len(MILLION)):
    output[i] = MILLION[i]
                    </code></pre>
                    <p>
                        <span class="bad">334 ms</span><br>
                    </p>
                    <pre><code class='python' data-trim data-noescape>
output = {}
for i, element in enumerate(MILLION):
    output[i] = element
                    </code></pre>
                    <p>
                        <span class="good">220 ms</span>
                    </p>
                    <pre><code class='python' data-trim data-noescape>
{i: element for i, element in enumerate(MILLION)}
                    </code></pre>
                    <p>
                        <span class="good">218 ms</span><br>
                        50% faster
                    </p>
                    <aside class="notes">
                        Ok, so for loops can often be avoided.<br>
                        But what if you need to iterate over a list and also get the index of each element ?<br>
                        Let's say, you want to take a list and convert it to a dictionary, in such way that index of each element becomes a key of that dictionary, and the value in the list becomes the value in the dictionary.<br>
                        There is a bad was to do this, where you basically iterate over the numbers from 0 to 1 million and take the value corresponding to that number in the list.<br>
                        A better idea would be to use the enumerate function to get the list elements together with the index.<br>
                        And this is going to be faster by 50%.<br>
                        But it's still a for loop with only one instruction inside, so it can easily be replaced with dictionary comprehension.<br>
                        The speed performance will be the same, but the code will be shorter and easier to read.
                    </aside>
                </section> -->

                <!-- Ask for permissions vs beg for forgiveness -->
                <section>
                    <section>
                        <h4 class="mb50"><span class="orange">#3</span> Permissions or forgiveness ?</h4>
                        <pre><code class='python' data-trim data-noescape>
class Foo(object):
    hello = 'world'
foo = Foo()
                        </code></pre>
                        <pre><code class='python' data-trim data-noescape>
if hasattr(foo, 'hello'):
    foo.hello
                        </code></pre>
                        <p>
                            <span class="bad">149 ns</span><br>
                        </p>
                        <pre><code class='python' data-trim data-noescape>
try:
    foo.hello
except AttributeError:
    pass
                        </code></pre>
                        <p>
                            <span class="good">43.1 ns</span><br>
                            3.5 times faster
                        </p>
                        <aside class="notes">
                            When you want to execute a piece of code, but you are not sure if it will be successful (maybe some variables are not set or like here, the class might not have a specific attribute), so you want to protect yourself somehow.<br>
                            The first way you can do this is called 'Look before you leap' or 'Ask for permission'.<br>
                            What is means is that you first check if the class has a specific attribute and then you perform the operations.<br>
                            Usually this checking is done with the if statement.<br>
                            However, there is a different approach that you could use - it's called "Beg for forgiveness".<br>
                            In this scenario, you perform your operations without checking the conditions, but in case you expect that something might break, you wrap your code in a try/except block and catch the exceptions that were raised.<br>
                            As you can see in this simple example, begging for forgiveness is 3 times faster.
                        </aside>
                    </section>
                    <section>
                    <h4 class="mb50"><span class="orange">#3</span> Permissions or forgiveness ?</h4>
                        <pre><code class='python' data-trim data-noescape>
if (hasattr(foo, 'foo') and hasattr(foo, 'bar')
    and hasattr(foo, 'baz')):
    foo.foo
    foo.bar
    foo.baz
                        </code></pre>
                        <p>
                            <span class="bad">401 ns</span>
                        </p>
                        <pre><code class='python' data-trim data-noescape>
try:
    foo.foo
    foo.bar
    foo.baz
except AttributeError:
    pass
                        </code></pre>
                        <p>
                            <span class="good">110 ns</span><br>
                            3.64 times faster
                        </p>
                        <aside class="notes">
                            But it gets even better if you are checking for more conditions.<br>
                            Here, we are checking if 3 attributes are available.<br>
                            Asking for permissions is still slower and now it also gets more difficult to read.<br>
                            Following the beg for forgiveness approach will result in faster and more readable code.<br>
                            So, we could say that asking for forgiveness instead of checking the permissions as always a better choice.
                        </aside>
                    </section>
                    <!-- Ask for permissions vs beg for forgiveness 3 -->
                    <section>
                    <h4 class="mb50"><span class="orange">#3</span> Permissions or forgiveness ?</h4>
                        <pre><code class='python' data-trim data-noescape>
class Bar(object):
    pass
bar = Bar()
                        </code></pre>
                        <pre><code class='python' data-trim data-noescape>
if hasattr(bar, 'hello'):
    bar.hello
                        </code></pre>
                        <p>
                            <span class="good">428 ns</span><br>
                        </p>
                        <pre><code class='python' data-trim data-noescape>
try:
    bar.hello
except AttributeError:
    pass
                        </code></pre>
                        <p>
                            <span class="bad">536 ns</span><br>
                            25% slower
                        </p>
                        <aside class="notes">
                            But we won't say that, because it's not true.<br>
                            Exceptions handling is still quite expensive.<br>
                            If the object doesn't have the attribute we are looking for, begging for forgiveness will be slower than asking for permissions.<br>
                            So as a rule of thumb, you can use the 'Ask for permissions' way if you know that it's very likely that the attribute will be missing or there will be some other problems that you can predict.<br>
                            Otherwise, if you are expecting that your code will work fine for most of the time, using try/except will be faster and quite often more readable way to go.<br>
                            For example, you are fetching some files from the internet and you are expecting that it will work, unless there is no internet connection, then instead of checking if there is network connection, if it's fast enough, no timeouts, etc. just go for try/except.<br>
                            But again, I strongly advise you to measure both solutions to see which one is faster in your scenario.
                        </aside>
                    </section>
                </section>




                <!-- Check list membership -->
                <section>
                    <section>
                        <h4 class="mb50"><span class="orange">#4</span> Membership testing</h4>
                        <pre><code class='python' data-trim data-noescape>
def check_number(number):
    for item in MILLION_NUMBERS:
        if item == number:
            return True
    return False
                        </code></pre>
                        <pre><code class='python' data-trim data-noescape>
%timeit check_number(500000)
                        </code></pre>
                        <p>
                            <span class="bad">18 ms</span>
                        </p>
                        <div class="fragment">
                            <pre><code class='python' data-trim data-noescape>
500000 in MILLION_NUMBERS
                            </code></pre>
                            <p>
                                <span class="good">8.45 ms</span><br>
                                2 times faster
                            </p>
                        </div>
                        <aside class="notes">
                            Let's tackle another problem - membership testing.<br>
                            If you have a list and want to check if it contains a specific element, you can use a for loop.<br>
                            But the problem is, you are iterating over the list, event though you are not really doing anything with all the elements.<br>
                            ###CLICK###<br>
                            You can replace the for loop with the in statement.<br>
                            It will check if a specific element belongs to given set of data.<br>
                            And it will do this twice as fast.<br>
                            Ok, but there is still one big problem with this approach.<br>
                        </aside>
                    </section>
                    <section>
                        <h4 class="mb50"><span class="orange">#4</span> Membership testing</h4>
                        <pre><code class='python' data-trim data-noescape>
100 in MILLION_NUMBERS
                        </code></pre>
                        <p>
                            <span class="bad">1.55 µs</span><br>
                        </p>
                        <pre><code class='python' data-trim data-noescape>
999999 in MILLION_NUMBERS
                        </code></pre>
                        <p>
                            <span class="bad">15.7 ms</span>
                        </p>
                        <aside class="notes">
                            The lookup time depends on where the element is located in that list.<br>
                            So, if an element is at the beginning of the list, you are lucky and you get it fast.<br>
                            If it's at the end, well, then you wait a bit more.<br>
                            You know what would be great here ?<br>
                            If we could have a data structure with faster lookup time.<br>
                            And we have - both a set and a dictionary have constant lookup time.<br>
                        </aside>
                    </section>
                    <section>
                        <h4 class="mb50"><span class="orange">#4</span> Membership testing</h4>
                        <pre><code class='python' data-trim data-noescape>
MILLION_SET = set(MILLION_NUMBERS)
%timeit 100 in MILLION_SET
                        </code></pre>
                        <p>
                            <span class="good">46.3 ns</span><br>
                            33 times faster (vs list)
                        </p>
                        <pre><code class='python' data-trim data-noescape>
%timeit 999999 in MILLION_SET
                        </code></pre>
                        <p>
                            <span class="good">63.3 ns</span><br>
                            248 000 times faster (vs list)
                        </p>
                        <div class="fragment">
                            <pre><code class='python' data-trim data-noescape>
%timeit set(MILLION_NUMBERS)
                            </code></pre>
                            <p>
                                <span class="bad">106 ms</span>
                            </p>
                        </div>
                        <aside class="notes">
                            If we replace the list with a set, the lookup time becomes faster.<br>
                            From few times faster to hundreds of thousands times faster.<br>
                            Where is the catch ?<br>
                            ###CLICK###<br>
                            Well, you pay some time for converting list to a set.<br>
                            In this example, converting list to a set is slower than any of the lookups in the list, so it doesn't make sense to do this.<br>
                            However, if you are testing membership of more than 1 element, very often it makes sense to convert the list to a set.
                        </aside>
                    </section>
                </section>



                <!-- Removing duplicates -->
                <section>
                    <h4 class="mb50"><span class="orange">#5</span> Remove duplicates</h4>
                    <pre><code class='python' data-trim data-noescape>
unique = []
for element in MILLION_ELEMENTS:
    if element not in unique:
        unique.append(element)
                    </code></pre>
                    <p>
                        <span class="bad">8.29 s</span>
                    </p>
                    <pre><code class='python' data-trim data-noescape>
set(MILLION_ELEMENTS)
                    </code></pre>
                    <p>
                        <span class="good">19.3 ms</span><br>
                        400 times faster
                    </p>
                    <p class="source-link">
                        <small><a href="https://github.com/brennerm/PyTricks/blob/master/removeduplicatefromlist.py">Trick with OrderedDict</a> (if order matters)</small>
                    </p>
                    <aside class="notes">
                        Speaking of sets, they have one interesting feature - they don't contain duplicates.<br>
                        So if you have a list of elements and you want to remove duplicates, the fastest way would be to convert this list to a set.<br>
                        But be aware that sets are unordered, so if you need to preserve the order, take a look at the ordered dictionary from the collection module.
                    </aside>
                </section>


                <!-- List sorting is faster in place -->
                <section>
                    <h4 class="mb50"><span class="orange">#6</span> List sorting</h4>
                    <pre><code class='python' data-trim data-noescape>
sorted(MILLION_RANDOM_NUMBERS)
                    </code></pre>
                    <p>
                        <span class="bad">467 ms</span>
                    </p>
                    <pre><code class='python' data-trim data-noescape>
MILLION_RANDOM_NUMBERS.sort()
                    </code></pre>
                    <p>
                        <span class="good">77.6 ms</span><br>
                        6 times faster
                    </p>
                    <aside class="notes">
                        If you want to sort a list, you can either do this in place with list.sort function or call the sorted function, that will create a new list.<br>
                        Unless you really need to have a new list, sorting in place will be faster<br>
                        For 1 million random numbers, sorting in place is 6 times faster than creating a new list.
                    </aside>
                </section>

                <!-- Execute operation 1000 times in a function than a function 1000 times -->
                <section>
                    <h4 class="mb50"><span class="orange">#7</span> 1000 operations and 1 function</h4>
                    <pre><code class='python' data-trim data-noescape>
def square(number):
    return number**2
squares = [square(i) for i in range(1000)]
                    </code></pre>
                    <p>
                        <span class="bad">399 µs</span>
                    </p>
                    <pre><code class='python' data-trim data-noescape>
def compute_squares():
    return [i**2 for i in range(1000)]
                    </code></pre>
                    <p>
                        <span class="good">314 µs</span><br>
                         27% faster
                    </p>
                    <aside class="notes">
                        If you want to perform the same operation on a large set of data, you have two options.<br>
                        You can write a function that performs the operation and then call this function 1000 time.<br>
                        Or, you can write a function that takes those 1000 elements and performs the operation inside.<br>
                        And the second approach will be faster, so if you can easily change your code and replace multiple calls to a function with one function, then probably it's a good idea.
                    </aside>
                </section>




                <!-- Checking for True -->
                <section>
                    <section>
                        <h4 class="mb50"><span class="orange">#8</span> Checking for True</h4>
                        <pre><code class='python' data-trim data-noescape>
if variable == True:
                        </code></pre>
                        <p>
                            <span class="bad">35.8 ns</span>
                        </p>
                        <pre><code class='python' data-trim data-noescape>
if variable is True:
                        </code></pre>
                        <p>
                            <span class="bad">28.7 ns</span><br>
                            24% faster
                        </p>
                        <pre><code class='python' data-trim data-noescape>
if variable:
                        </code></pre>
                        <p>
                            <span class="good">20.6 ns</span><br>
                            73% faster
                        </p>
                        <aside class="notes">
                            What is the best way to check if a variable or expression is True ?<br>
                            You can explicitly compare this variable to True, but in most cases, it's adding unnecessary redundancy.<br>
                            You can simplify your condition to just 'if variable'.<br>
                            It will return True, unless the variable is False, None, 0, empty string, empty list or any other "Falsy" expression.<br>
                            And by doing that, your comparison gets faster by 70%.
                        </aside>
                    </section>
                    <!-- Checking for False -->
                    <section>
                        <h4 class="mb50"><span class="orange">#8</span> Checking for False</h4>
                        <pre><code class='python' data-trim data-noescape>
if variable == False:
                        </code></pre>
                        <p>
                            <span class="bad">35.1 ns</span>
                        </p>
                        <pre><code class='python' data-trim data-noescape>
if variable is False:
                        </code></pre>
                        <p>
                            <span class="bad">26.9 ns</span><br>
                            30% faster
                        </p>
                        <pre><code class='python' data-trim data-noescape>
if not variable:
                        </code></pre>
                        <p>
                            <span class="good">19.8 ns</span><br>
                            77% faster
                        </p>
                        <aside class="notes">
                            The same rule applies when checking for False.<br>
                            The fastest way to do this is to use 'if not variable', unless you really need to distinguish False from None, 0 or other Falsy values.
                        </aside>
                    </section>
                    <!-- Checking for empty list -->
                    <section>
                        <h4 class="mb50"><span class="orange">#8</span> Checking for empty list</h4>
                        <pre><code class='python' data-trim data-noescape>
if len(a_list) == 0:
                        </code></pre>
                        <p>
                            <span class="bad">91.7 ns</span>
                        </p>
                        <pre><code class='python' data-trim data-noescape>
if a_list == []:
                        </code></pre>
                        <p>
                            <span class="bad">56.3 ns</span><br>
                            60% faster
                        </p>
                        <pre><code class='python' data-trim data-noescape>
if not a_list:
                        </code></pre>
                        <p>
                            <span class="good">32.4 ns</span><br>
                            280% faster
                        </p>
                        <aside class="notes">
                            It also applies to empty data structures, like lists for example.<br>
                            Simply doing "if not a_list", will be almost 3 times faster than explicitly checking for the length of a list.
                        </aside>
                    </section>
                </section>

                <!-- Lambda vs def -->
                <section>
                    <section>
                    <h4><span class="orange">#9</span> Def vs lambda</h4>
                        <pre><code class='python' data-trim data-noescape>
def greet(name):
    return 'Hello {}!'.format(name)
                        </code></pre>
                        <p>
                            <span class="good">329 ns</span>
                        </p>
                        <pre><code class='python' data-trim data-noescape>
greet = lambda name: 'Hello {}!'.format(name)
                        </code></pre>
                        <p>
                            <span class="good">332 ns</span>
                        </p>
                        <aside class="notes">
                            Let's take a look at different ways of defining functions in Python.<br>
                            The most common way to create a function is with def keyword.<br>
                            The other way is to declare an anonymous function with lambda.<br>
                            If you assign this lambda to a variable it will act in the same way as function created with def keyword.<br>
                            And as you can see, they are both equally fast.<br>
                            Why ? Because both version do exactly the same thing.
                        </aside>
                    </section>
                    <section>
                    <h4><span class="orange">#9</span> Def vs lambda</h4>
                        <pre><code class='python' data-trim data-noescape>
>>> dis.dis(greet)
 0 LOAD_CONST    1 ('Hello {}!')
 3 LOAD_ATTR     0 (format)
 6 LOAD_FAST     0 (name)
 9 CALL_FUNCTION 1 (1 positional, 0 keyword pair)
12 RETURN_VALUE
                        </code></pre>
                        <small class="source-link"><a href='http://stackoverflow.com/questions/29804774/why-is-lambda-expression-necessary-in-this-example-python'>Stack Overflow question on when lambda might be necessary</a></small>
                        <aside class="notes">
                            We can disassemble the code of both versions with the dis library and we will see that inside, it's the same code.<br>
                            So is there any difference ?<br>
                            Well, if your function has more than one line, then you can't use lambda.<br>
                            Also, you can't really put documentation inside lambda function.<br>
                            And if you have PEP-8 enabled in you code editor, it will complain each time you try to assign lambda to a variable.<br>
                            And he is right, lambda works really nice when you need a simple one-liner callback for functions, especially for functions like filter, map or reduce.<br>
                            There are also some quite narrow use cases when it might be necessary to use the lambda as a callback - if you want to read more, you can check the link at the bottom of this slide.<br>
                            However, for any other case, I would use def. It's much cleaner, you can document it properly and the performance is the same.<br>
                        </aside>
                    </section>
                </section>
                <!-- [] vs list() and {} vs dict() -->
                <section>
                    <section>
                        <h4><span class="orange">#10</span> list() or []</h4>
                        <pre><code class='python' data-trim data-noescape>
list()
                        </code></pre>
                        <p>
                            <span class="bad">104 ns</span>
                        </p>
                        <pre><code class='python' data-trim data-noescape>
[]
                        </code></pre>
                        <p>
                            <span class="good">22.5 ns</span>
                        </p>
                        <p>
                            4.6 times faster
                        </p>
                        <aside class="notes">
                            There are 2 ways how you can create an empty list.<br>
                            You can either call a list function or you can use the literal syntax.<br>
                            And as you can see, using the literal syntax is way faster.<br>
                            It's faster, because if you call a function, Python needs to resolve this function first.<br>
                            With the literal syntax, there is no overhead for that.
                        </aside>
                    </section>
                    <section>
                        <h4><span class="orange">#10</span> dict() or {}</h4>
                        <pre><code class='python' data-trim data-noescape>
dict()
                        </code></pre>
                        <p>
                            <span class="bad">161 ns</span>
                        </p>
                        <pre><code class='python' data-trim data-noescape>
{}
                        </code></pre>
                        <p>
                            <span class="good">93 ns</span>
                        </p>
                        <p>
                            1.7 times faster
                        </p>
                        <aside class="notes">
                            Exact same thing happens for creating a dictionary.<br>
                        </aside>
                    </section>
                </section>
                <!-- DANGER ZONE - although those examples are faster, I don't recommend them as they make your code less readable !!!
                     Treat those examples as curiosities -->
                <!-- Parallel vs sequential variables assignment -->
                <section class="danger">
                    <h1 class="danger">Danger zone</h1>
                    <aside class="notes">
                        I have 2 more slides that should be treated with caution.<br>
                        Even though the code can run faster there, I don't advise you to do this kind of optimizations.<br>
                        Sometimes, even though you can squeeze some more speed from your code, it doesn't mean that you should do this.
                    </aside>
                </section>
                <section>
                <h4><span class="orange">#11</span> Variables assignment</h4>
                    <pre><code class='python' data-trim data-noescape>
q=1
w=2
e=3
r=4
t=5
y=6
u=7
i=8
o=9
p=0

                    </code></pre>
                    <p>
                        <span class="bad">71.8 ns</span>
                    </p>
                    <pre><code class='python' data-trim data-noescape>
q,w,e,r,t,y,u,i,o,p = 1,2,3,4,5,6,7,8,9,0
                    </code></pre>
                    <p>
                        <span class="good">56.4 ns</span><br>
                        27% faster (but please don't)
                    </p>
                    <aside class="notes">
                        So, one thing is variables assignments.<br>
                        If you have a bunch of variables that you need to assign, you can either do this the normal, sequential way or you can go for this crazy parallel assignment.<br>
                        Indeed, you can gain some speed, but with this speed comes the hate of your colleagues reading this code later.<br>
                        In my opinion, it's not worth it.
                    </aside>
                </section>
                <!-- Local vs global/built-in variables  -->
                <section>
                <h4><span class="orange">#12</span> Variables lookup</h4>
                    <pre><code class='python' data-trim data-noescape>
def squares(MILLION_NUMBERS):
    output = []
    for element in MILLION_NUMBERS:
        output.append(element*element)
    return output
                    </code></pre>
                    <p>
                        <span class="bad">149 ms</span>
                    </p>
                    <pre><code class='python' data-trim data-noescape>
def squares_faster(MILLION_NUMBERS):
    output = []
    append = output.append # <= !!!!!!!!
    for element in MILLION_NUMBERS:
        append(element*element)
    return output
                    </code></pre>
                    <p>
                        <span class="good">110 ms</span><br>
                        35% faster (and 27% more confusing)
                    </p>
                    <aside class="notes">
                        Another interesting property of Python - the lookup for local variables is faster than the lookup for globals or built-ins.<br>
                        So you can save some time if, for example, you store the reference to a built-in function or a global function in a local variable.<br>
                        In this example, the only difference is that on line 3, I'm storing the reference to the append function in a variable called append.<br>
                        Thanks to that, this function is 35% faster, but then again, if you see this code for the first time, it's not obvious what it is supposed to do.<br>
                        It might be confusing to see this append function, as we are used to see the list.append version more often.
                    </aside>
                </section>
                <section>
                    <h2>Summary</h2>
                    <ul>
                        <li>There are different <span class="orange">kinds</span> of optimization</li>
                        <li>There are different <span class="orange">levels</span> of optimization</li>
                        <li>Source code optimizations <span class="orange">adds up</span></li>
                        <li>Source code optimizations <span class="orange">is cheap</span>
                            <ul>
                                <li>Idiomatic Python</li>
                                <li>Don't reinvent the wheel</li>
                            </ul>
                        </li>
                        <li>Profile your code and be curious!</li>
                    </ul>
                    <aside class="notes">
                        To sum up - there are different kinds of optimization, it's quite often about the speed, but not always.<br>
                        There are different levels of optimization, sometimes if you can't rewrite your whole application, maybe you can use a different approach?<br>
                        Even though the source code optimization might not be the fastest way to optimize your code, those small improvements will add up.<br>
                        And the main advantage of it, is that it's cheap.<br>
                        You don't need to make huge changes, you can optimize your code at the moment of writing.<br>
                        If you write idiomatic code and don't reinvent the wheel but use the existing functions and data structures, then you are already good.<br>
                        So be curious when your are coding.<br>
                        If you think that a different code structure will be faster, you can quickly check it with timeit and improve it.
                    </aside>
                </section>
                <section>
                    <h1>Thank you!</h1>
                    <h2 class="orange" style='margin-bottom:100px;'>Happy and <span class='fire'>fast</span> coding!</h2>
                    <small class='source-link source-link--light'>Check the slides at GitHub:<br>
                    <a href="http://switowski.github.io/europython2016">http://switowski.github.io/europython2016</a></small>
                    <aside class="notes">
                        Thank you for your attention, do you have any questions ?
                    </aside>
                </section>
            </div>
        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>

        <script>
            // More info https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                history: true,
                slideNumber: 'c/t',

                // More info https://github.com/hakimel/reveal.js#dependencies
                dependencies: [
                    { src: 'plugin/markdown/marked.js' },
                    { src: 'plugin/markdown/markdown.js' },
                    { src: 'plugin/notes/notes.js', async: true },
                    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
                ]
            });
        </script>
    </body>
</html>
